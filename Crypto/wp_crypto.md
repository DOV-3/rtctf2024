# 绵羊套中套

首先拿到题目描述后观察发现是jsfuck编码，通过jsfuck解密得到：

```
cwIjVxBVbjlDf=jdwR2Yt91UwAQADM7UzZU9ndh=
```

观察发现这一串字符中有两个等号，但是并不是都在末尾。

我们知道如果都在末尾的话是有很大概率是我们的base64编码。所以怀疑此处做了一些移位操作。

根据题目中的“绵羊”以及hint.txt中提示“跳了三次”，可以得到此处应该是栅栏编码，栅栏数为3。

可以找一些网上在线工具或者自己写一个脚本来实现（因为我找不到好用的，就自己写了一下，注意此时对应的字母不能随意更换大小写！）

甩个脚本在这里，你们也可以拿来用：

```python
import math
def fun_enCrypto(string_C , Ek):
    string_M = ''
    n = 0
    while n < Ek:
        m = 0
        while m < len(string_C) / Ek:
            if (m * Ek+ n) < len(string_C):
                string_M = string_M + string_C[int(m * Ek+ n)]
                m += 1
            else :
                break
        n += 1
    return string_M

def fun_deCrypto(string_M, Ek):
    n = len(string_M)
    base_group_size = n // Ek
    remainder = n % Ek

    group_sizes = [base_group_size + 1 if i < remainder else base_group_size for i in range(Ek)]

    groups = []
    start_index = 0
    for size in group_sizes:
        groups.append(string_M[start_index:start_index + size])
        start_index += size

    decrypted_text = ''
    for i in range(max(group_sizes)):  # 遍历每一栅栏可能的最大高度
        for j in range(Ek):  # 按栅栏数遍历
            if i < len(groups[j]):  # 只有当前栅栏高度在范围内时才添加字符
                decrypted_text += groups[j][i]

    return decrypted_text

if __name__ == __name__:
    a = input("please input ciper text: ")
    Ek = int(input("please input key: "))
    print(fun_deCrypto(a,Ek))
```

得到输出`cjAwdDIwMjR7V2UxYzBtZV9Ub19jUnlwdDAhfQ==`

再利用base64解密得到flag：

`r00t2024{We1c0me_To_cRypt0!}`



# 干支纪年法

首先观察题干描述：

```
我们可爱的鬼宝队长一天收到了来自xyy大佬的一封密信，其中写了一些不同的年份：
	壬辰，甲寅，庚申，戊戌，戊辰，丁巳，甲辰，戊戌，甲戌，甲寅，壬午，癸卯，戊戌，庚子，己未，戊戌，壬寅，丁巳，壬辰，癸未，己未，壬午

信的背面还写有“+甲子”，请试图解出这段密文
```

由题目“干支纪年法”可知，本题利用60为一甲子来进行数字的替换。

![image-20240426103334430](C:/Users/ROG/AppData/Roaming/Typora/typora-user-images/image-20240426103334430.png)

简单的替换后得到原来的一组数据是：

```
29,51,57,35,05,54,41,35,11,51,19,40,35,37,56,35,39,54,29,20,56,19
```

提示说还需要加一甲子，即每个数字加60

```
89,111,117,95,65,114,101,95,71,111,79,100,95,97,116,95,99,114,89,80,116,79
```

然后可以得到这是ascii码，找出对应的字符即可：

```python
a = [89,111,117,95,65,114,101,95,71,111,79,100,95,97,116,95,99,114,89,80,116,79]
for i in a:
    print(chr(i),end='')
```

得到flag：

`You_Are_GoOd_at_crYPtO`

然后包上`r00t2024{}`后提交即可



# hex keyboard

首先阅读题干：

```
65 57 64 69 62 6d 70 31 49 48 46 7a 65 69 41 77 62 32 77 37 57 79 30 67 4d 47 39 73 4f 31 73 74 49 44 5a 30 5a 32 68 31 4e 79 41 77 63 46 73 39 49 47 52 34 5a 6e 59 67 4e 47 56 6b 5a 6e 51 31 49 44 5a 30 5a 32 68 31 4e 79 41 77 62 32 77 37 57 79 30 67 4e 58 4a 6d 5a 33 6b 32 49 44 6c 70 61 32 78 77 4d 43 41 79 63 51 3d 3d
```

根据题目提示和题干数字的格式可以得到这是一堆十六进制的数字，那我们可以用cyberchef的from hex将这些十六进制的数据转换成对应的字符：

```
eWdibmp1IHFzeiAwb2w7Wy0gMG9sO1stIDZ0Z2h1NyAwcFs9IGR4ZnYgNGVkZnQ1IDZ0Z2h1NyAwb2w7Wy0gNXJmZ3k2IDlpa2xwMCAycQ==
```

很明显是一串base64

```
ygbnju qsz 0ol;[- 0ol;[- 6tghu7 0p[= dxfv 4edft5 6tghu7 0ol;[- 5rfgy6 9iklp0 2q
```

得到这么一串看起来像乱码的东西，但是根据题目中的“keyboard”提示，可以观看键盘中这些字符的位置。用第一个举例子，你会发现六个字符把`h`包裹起来了，后面同理，可以得到本题flag：

```
happy_crypto!
```

同理，包上r00t2024{}提交即可



# ez_rsa

首先阅读题干：

```python
from gmpy2 import lcm , powmod , invert , gcd , mpz
from Crypto.Util.number import getPrime
from sympy import nextprime
from random import randint

p = getPrime(1024)
q = getPrime(1024)
n = p * q
gift = lcm(p - 1 , q - 1)
e = 65537
flag = b'r00t2024{XXXXXXXXXXXXX}'
m = int.from_bytes(flag , 'big')
c = powmod(m , e , n)
print('n: ' , n)
print('gift: ' , gift)
print('c: ' , c)

'''
n:  14347257961459348762826574333642954904450160321341720290367756737691205339647046742262025420186291721491196523046061645217835565255079987391880265411247468616738936818336768939257716538950654321113453596355689777113875852727511950968209816705680849662809452449692195981973357825680572749266081067543058120232377014813189939848428110891006747487211012399676376229188710360838171767117158004048826610385024922221144008795130935792818435567054857403686722968380935128742110628745432886844535319427592646544898002680835692734008164220185178061291673000934447397248197134246661425590385799878120904607577913136838020003757
gift:  3586814490364837190706643583410738726112540080335430072591939184422801334911761685565506355046572930372799130761515411304458891313769996847970066352811867154184734204584192234814429134737663580278363399088922444278468963181877987742052454176420212415702363112423048995493339456420143187316520266885764530058034213984068222730104526620915276935610037149262963989180780823254199460203404130922779114951003154468623837163747301415788506257394432111971249939930190623004010828644954345144382022285648776685520198124647964878882233913454926887367287033636361936535824031934945200885639287766338519911212648545122052722064
c:  5884615664079149791505635618526424461431630318297039596540366545703925520459923270885231808693071837903203732439615490892995303781165132717440126940731900095919916968333903944416594993901007405527190160282994522126669139201893889700934617754629274280592248878132895637259785453513413763381122398602062310006984823004954109151914576922184685617564781860589867202492729060160952896865633413966121138288239540682101883407904180269234687206790419673692286207029824477454317655202167556263908118595997806490467595605323835098119528014284721427857904537483795134273587285100779675107231104080762187051480482061998107751205

'''
```

$m=c^d mod n$

我们有 c , e , n ，目标需要得到d，又

$ed\equiv1 mod (p-1)*(q-1)$

现在需要得到p,q的值：

- 首先尝试了分解n，发现过与大，并不能分解出来

- 接着我们观察本题，发现目前为止还有一个变量`gift = lcm(p - 1 , q - 1)`并没有使用，那么下一步突破点应该在于这个变量上，考虑到`gift`是`(p-1)`和`(q-1)`的最小公倍数，又已知如下公式：
	- $(p-1)*(q-1) = lcm(p-1,q-1)*gcd(q-1,p-1)$
- 使用`len`发现`gift`位数只比`n`小1位，考虑暴力枚举1到10，从而得到phi

```python
import random
from gmpy2 import lcm, powmod, invert, gcd, mpz, gmpy2
from libnum import n2s
from sympy import *

def getpq(n,e,d): #知道n,e,d，求p,q
    while True:
        k = e * d - 1
        g = random.randint(0, n)
        while k%2==0:
            k=k//2
            temp=powmod(g,k,n)-1
            if gcd(temp,n)>1 and temp!=0:
                return gcd(temp,n)

n = 14347257961459348762826574333642954904450160321341720290367756737691205339647046742262025420186291721491196523046061645217835565255079987391880265411247468616738936818336768939257716538950654321113453596355689777113875852727511950968209816705680849662809452449692195981973357825680572749266081067543058120232377014813189939848428110891006747487211012399676376229188710360838171767117158004048826610385024922221144008795130935792818435567054857403686722968380935128742110628745432886844535319427592646544898002680835692734008164220185178061291673000934447397248197134246661425590385799878120904607577913136838020003757
gift = 3586814490364837190706643583410738726112540080335430072591939184422801334911761685565506355046572930372799130761515411304458891313769996847970066352811867154184734204584192234814429134737663580278363399088922444278468963181877987742052454176420212415702363112423048995493339456420143187316520266885764530058034213984068222730104526620915276935610037149262963989180780823254199460203404130922779114951003154468623837163747301415788506257394432111971249939930190623004010828644954345144382022285648776685520198124647964878882233913454926887367287033636361936535824031934945200885639287766338519911212648545122052722064
c = 5884615664079149791505635618526424461431630318297039596540366545703925520459923270885231808693071837903203732439615490892995303781165132717440126940731900095919916968333903944416594993901007405527190160282994522126669139201893889700934617754629274280592248878132895637259785453513413763381122398602062310006984823004954109151914576922184685617564781860589867202492729060160952896865633413966121138288239540682101883407904180269234687206790419673692286207029824477454317655202167556263908118595997806490467595605323835098119528014284721427857904537483795134273587285100779675107231104080762187051480482061998107751205
e = 65537

for i in range(10):
    phi=gift*i
    try:
        d=gmpy2.invert(e,phi)
        p = getpq(n,e,d)
        q = n // p
        assert (p-1)*(q-1) == phi #确定正确的p,q
        m=gmpy2.powmod(c,d,n)
        print(n2s(int(m)))
    except:
        pass
```

解释一下为什么有这个东西，按道理来说，只需要1到10暴力枚举，每次只要不出错就会把flag输出出来，但是实际上如果这么做了，你会发现十次输出的flag一摸一样，但是phi居然不相同！！，这个问题是和数据规模有关系的，有兴趣可以自己自行搜索钻研一下，这里给出`assert`是为了确定正确的phi，但实际上你如果不正确竟然也可以解出来。

```python
import random
from gmpy2 import lcm, powmod, invert, gcd, mpz, gmpy2
from libnum import n2s
from sympy import *

n = 14347257961459348762826574333642954904450160321341720290367756737691205339647046742262025420186291721491196523046061645217835565255079987391880265411247468616738936818336768939257716538950654321113453596355689777113875852727511950968209816705680849662809452449692195981973357825680572749266081067543058120232377014813189939848428110891006747487211012399676376229188710360838171767117158004048826610385024922221144008795130935792818435567054857403686722968380935128742110628745432886844535319427592646544898002680835692734008164220185178061291673000934447397248197134246661425590385799878120904607577913136838020003757
gift = 3586814490364837190706643583410738726112540080335430072591939184422801334911761685565506355046572930372799130761515411304458891313769996847970066352811867154184734204584192234814429134737663580278363399088922444278468963181877987742052454176420212415702363112423048995493339456420143187316520266885764530058034213984068222730104526620915276935610037149262963989180780823254199460203404130922779114951003154468623837163747301415788506257394432111971249939930190623004010828644954345144382022285648776685520198124647964878882233913454926887367287033636361936535824031934945200885639287766338519911212648545122052722064
c = 5884615664079149791505635618526424461431630318297039596540366545703925520459923270885231808693071837903203732439615490892995303781165132717440126940731900095919916968333903944416594993901007405527190160282994522126669139201893889700934617754629274280592248878132895637259785453513413763381122398602062310006984823004954109151914576922184685617564781860589867202492729060160952896865633413966121138288239540682101883407904180269234687206790419673692286207029824477454317655202167556263908118595997806490467595605323835098119528014284721427857904537483795134273587285100779675107231104080762187051480482061998107751205
e = 65537

for i in range(10):
    phi=gift*i
    try:
        d=gmpy2.invert(e,phi)
        m=gmpy2.powmod(c,d,n)
        print(n2s(int(m)))
    except:
        pass
```

即，上述脚本也可以跑出来正确结果，而且有十个，那么这个问题留给后面讲解，此处你只需要有个印象即可。

最后正确flag

`r00t2024{Easy_Rsa1_f1act0r!}`



# baby_xor

题干：

```python
from os import urandom
from secret import flag
key = urandom(1)

def xor(plaintext, key):
    ret = []
    for i in range(len(plaintext)):
        ret.append(plaintext[i] ^ key[0])
    return bytes(ret)

ciphertext = xor(flag, key)

print(ciphertext.hex())

'''
edafafebadafadabe4e7afedc0f6aac0eeeaaeebacc0acfee5e6e2
'''
```

首先学一个知识点`urandom()`函数:

`urandom(int n)`表示生成一个n字节的串

`key[0]`表示这个key对应hex的十进制数值



我们知道对同一个数异或两次还是等于本身，所以只需要暴力破解key，每一个key都异或一次即可，一字节，那么从0到256都异或一次即可，注意此处的异或是字节进行：

```python
import binascii
c = 'edafafebadafadabe4e7afedc0f6aac0eeeaaeebacc0acfee5e6e2'

def xor(plaintext, key):
    ret = []
    for i in range(len(plaintext)):
        ret.append(plaintext[i] ^ key[0])
    return bytes(ret)

c = binascii.a2b_hex(c)

for i in range(0, 256):

    key = bytes([i])
    ciphertext = xor(c, key)

    if b'r00t2024' in ciphertext:
        try:
            print(ciphertext.decode())
        except UnicodeDecodeError:
            print("Found 'flag' but cannot decode:", ciphertext)
```

`binascii.a2b_hex()`是将十六进制字符串转换成ASCII字节

后面key也通过` key = bytes([i])`变成字节类型再进行异或

由于异或出来有很多不需要的结果，所以最后筛选一下再输出`if b'r00t2024' in ciphertext:`

最后得到flag

`r00t2024{x0r_i5_qu1t3_3azy}`